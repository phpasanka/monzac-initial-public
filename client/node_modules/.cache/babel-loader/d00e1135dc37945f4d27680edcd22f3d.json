{"ast":null,"code":"var _jsxFileName = \"C:\\\\OpenMonzac\\\\client\\\\src\\\\mainComponents\\\\articleEditor.js\";\nimport React, { Component } from \"react\";\nimport ContentEditable from \"react-contenteditable\";\nimport { MonzacContext } from \"../context/monzacContext\";\n\nclass ArticleEditor extends Component {\n  constructor() {\n    super();\n\n    this.handleChange = evt => {\n      this.setState({\n        html: evt.target.value\n      });\n    };\n\n    this.render = () => {\n      return;\n      React.createElement(MonzacContext.Consumer, {\n        __source: {\n          fileName: _jsxFileName,\n          lineNumber: 18\n        },\n        __self: this\n      }, React.createElement(ContentEditable, {\n        innerRef: this.contentEditable,\n        html: this.state.html // innerHTML of the editable div\n        ,\n        disabled: false // use true to disable editing\n        ,\n        onChange: this.handleChange // handle innerHTML change\n        ,\n        tagName: \"article\" // Use a custom HTML tag (uses a div by default)\n        ,\n        __source: {\n          fileName: _jsxFileName,\n          lineNumber: 19\n        },\n        __self: this\n      }));\n    };\n\n    this.contentEditable = React.createRef();\n    this.state = {\n      html: \"<b>Hello <i>World</i></b>\"\n    };\n  }\n\n}\n\nexport default ArticleEditor; // class ArticleEditor extends Component {\n//   state = {};\n//   render() {\n//     return (\n//       <MonzacContext.Consumer>\n//         {(context) => (\n//           <p\n//             id=\"id-article-editor-content\"\n//             contentEditable\n//             onInput={context.updateNewArticleContent}\n//             data-placeholder=\"Write here...!\"\n//           ></p>\n//         )}\n//       </MonzacContext.Consumer>\n//     );\n//   }\n// }\n// export default ArticleEditor;\n// class ArticleEditor extends React.Component {\n//   constructor() {\n//     super();\n//     this.emitChange = this.emitChange.bind(this);\n//   }\n//   render() {\n//     var { tagName, html, onChange, ...props } = this.props;\n//     // return React.createElement(\n//     //   tagName || \"div\",\n//     //   {\n//     //     ...props,\n//     //     ref: (e) => (this.htmlEl = e),\n//     //     onInput: this.emitChange,\n//     //     onBlur: this.props.onBlur || this.emitChange,\n//     //     contentEditable: !this.props.disabled,\n//     //     dangerouslySetInnerHTML: { __html: html },\n//     //   },\n//     //   this.props.children\n//     // );\n//     return (\n//      <MonzacContext.Consumer>\n//      <p>\n//       </p>\n//       </MonzacContext.Consumer>\n//     );\n//   }\n//   shouldComponentUpdate(nextProps) {\n//     // We need not rerender if the change of props simply reflects the user's\n//     // edits. Rerendering in this case would make the cursor/caret jump.\n//     return (\n//       // Rerender if there is no element yet... (somehow?)\n//       !this.htmlEl ||\n//       // ...or if html really changed... (programmatically, not by user edit)\n//       (nextProps.html !== this.htmlEl.innerHTML &&\n//         nextProps.html !== this.props.html) ||\n//       // ...or if editing is enabled or disabled.\n//       this.props.disabled !== nextProps.disabled\n//     );\n//   }\n//   componentDidUpdate() {\n//     if (this.htmlEl && this.props.html !== this.htmlEl.innerHTML) {\n//       // Perhaps React (whose VDOM gets outdated because we often prevent\n//       // rerendering) did not update the DOM. So we update it manually now.\n//       this.htmlEl.innerHTML = this.props.html;\n//     }\n//   }\n//   emitChange(evt) {\n//     if (!this.htmlEl) return;\n//     var html = this.htmlEl.innerHTML;\n//     if (this.props.onChange && html !== this.lastHtml) {\n//       evt.target = { value: html };\n//       this.props.onChange(evt);\n//     }\n//     this.lastHtml = html;\n//   }\n// }\n// export default ArticleEditor;","map":{"version":3,"sources":["C:/OpenMonzac/client/src/mainComponents/articleEditor.js"],"names":["React","Component","ContentEditable","MonzacContext","ArticleEditor","constructor","handleChange","evt","setState","html","target","value","render","contentEditable","state","createRef"],"mappings":";AAAA,OAAOA,KAAP,IAAgBC,SAAhB,QAAiC,OAAjC;AACA,OAAOC,eAAP,MAA4B,uBAA5B;AACA,SAASC,aAAT,QAA8B,0BAA9B;;AAEA,MAAMC,aAAN,SAA4BH,SAA5B,CAAsC;AACpCI,EAAAA,WAAW,GAAG;AACZ;;AADY,SAMdC,YANc,GAMEC,GAAD,IAAS;AACtB,WAAKC,QAAL,CAAc;AAAEC,QAAAA,IAAI,EAAEF,GAAG,CAACG,MAAJ,CAAWC;AAAnB,OAAd;AACD,KARa;;AAAA,SAUdC,MAVc,GAUL,MAAM;AACb;AACA,0BAAC,aAAD,CAAe,QAAf;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA,SACE,oBAAC,eAAD;AACE,QAAA,QAAQ,EAAE,KAAKC,eADjB;AAEE,QAAA,IAAI,EAAE,KAAKC,KAAL,CAAWL,IAFnB,CAEyB;AAFzB;AAGE,QAAA,QAAQ,EAAE,KAHZ,CAGmB;AAHnB;AAIE,QAAA,QAAQ,EAAE,KAAKH,YAJjB,CAI+B;AAJ/B;AAKE,QAAA,OAAO,EAAC,SALV,CAKoB;AALpB;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA,QADF;AASD,KArBa;;AAEZ,SAAKO,eAAL,GAAuBb,KAAK,CAACe,SAAN,EAAvB;AACA,SAAKD,KAAL,GAAa;AAAEL,MAAAA,IAAI,EAAE;AAAR,KAAb;AACD;;AALmC;;AAwBtC,eAAeL,aAAf,C,CAEA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AAEA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AAEA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA","sourcesContent":["import React, { Component } from \"react\";\r\nimport ContentEditable from \"react-contenteditable\";\r\nimport { MonzacContext } from \"../context/monzacContext\";\r\n\r\nclass ArticleEditor extends Component {\r\n  constructor() {\r\n    super();\r\n    this.contentEditable = React.createRef();\r\n    this.state = { html: \"<b>Hello <i>World</i></b>\" };\r\n  }\r\n\r\n  handleChange = (evt) => {\r\n    this.setState({ html: evt.target.value });\r\n  };\r\n\r\n  render = () => {\r\n    return;\r\n    <MonzacContext.Consumer>\r\n      <ContentEditable\r\n        innerRef={this.contentEditable}\r\n        html={this.state.html} // innerHTML of the editable div\r\n        disabled={false} // use true to disable editing\r\n        onChange={this.handleChange} // handle innerHTML change\r\n        tagName=\"article\" // Use a custom HTML tag (uses a div by default)\r\n      />\r\n    </MonzacContext.Consumer>;\r\n  };\r\n}\r\nexport default ArticleEditor;\r\n\r\n// class ArticleEditor extends Component {\r\n//   state = {};\r\n\r\n//   render() {\r\n//     return (\r\n//       <MonzacContext.Consumer>\r\n//         {(context) => (\r\n//           <p\r\n//             id=\"id-article-editor-content\"\r\n//             contentEditable\r\n//             onInput={context.updateNewArticleContent}\r\n//             data-placeholder=\"Write here...!\"\r\n//           ></p>\r\n//         )}\r\n//       </MonzacContext.Consumer>\r\n//     );\r\n//   }\r\n// }\r\n// export default ArticleEditor;\r\n\r\n// class ArticleEditor extends React.Component {\r\n//   constructor() {\r\n//     super();\r\n//     this.emitChange = this.emitChange.bind(this);\r\n//   }\r\n\r\n//   render() {\r\n//     var { tagName, html, onChange, ...props } = this.props;\r\n\r\n//     // return React.createElement(\r\n//     //   tagName || \"div\",\r\n//     //   {\r\n//     //     ...props,\r\n//     //     ref: (e) => (this.htmlEl = e),\r\n//     //     onInput: this.emitChange,\r\n//     //     onBlur: this.props.onBlur || this.emitChange,\r\n//     //     contentEditable: !this.props.disabled,\r\n//     //     dangerouslySetInnerHTML: { __html: html },\r\n//     //   },\r\n//     //   this.props.children\r\n//     // );\r\n//     return (\r\n//      <MonzacContext.Consumer>\r\n//      <p>\r\n\r\n//       </p>\r\n//       </MonzacContext.Consumer>\r\n//     );\r\n\r\n//   }\r\n\r\n//   shouldComponentUpdate(nextProps) {\r\n//     // We need not rerender if the change of props simply reflects the user's\r\n//     // edits. Rerendering in this case would make the cursor/caret jump.\r\n//     return (\r\n//       // Rerender if there is no element yet... (somehow?)\r\n//       !this.htmlEl ||\r\n//       // ...or if html really changed... (programmatically, not by user edit)\r\n//       (nextProps.html !== this.htmlEl.innerHTML &&\r\n//         nextProps.html !== this.props.html) ||\r\n//       // ...or if editing is enabled or disabled.\r\n//       this.props.disabled !== nextProps.disabled\r\n//     );\r\n//   }\r\n\r\n//   componentDidUpdate() {\r\n//     if (this.htmlEl && this.props.html !== this.htmlEl.innerHTML) {\r\n//       // Perhaps React (whose VDOM gets outdated because we often prevent\r\n//       // rerendering) did not update the DOM. So we update it manually now.\r\n//       this.htmlEl.innerHTML = this.props.html;\r\n//     }\r\n//   }\r\n\r\n//   emitChange(evt) {\r\n//     if (!this.htmlEl) return;\r\n//     var html = this.htmlEl.innerHTML;\r\n//     if (this.props.onChange && html !== this.lastHtml) {\r\n//       evt.target = { value: html };\r\n//       this.props.onChange(evt);\r\n//     }\r\n//     this.lastHtml = html;\r\n//   }\r\n// }\r\n// export default ArticleEditor;\r\n"]},"metadata":{},"sourceType":"module"}