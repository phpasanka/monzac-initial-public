{"ast":null,"code":"import React, { Component } from \"react\";\nimport { MonzacContext } from \"../context/monzacContext\"; // class ArticleEditor extends Component {\n//   state = {};\n//   render() {\n//     return (\n//       <MonzacContext.Consumer>\n//         {(context) => (\n//           <p\n//             id=\"id-article-editor-content\"\n//             contentEditable\n//             onInput={context.updateNewArticleContent}\n//             data-placeholder=\"Write here...!\"\n//           ></p>\n//         )}\n//       </MonzacContext.Consumer>\n//     );\n//   }\n// }\n// export default ArticleEditor;\n\nclass ArticleEditor extends React.Component {\n  constructor() {\n    super();\n    this.emitChange = this.emitChange.bind(this);\n  }\n\n  render() {\n    var {\n      tagName,\n      html,\n      onChange,\n      ...props\n    } = this.props;\n    return;\n    React.createElement(tagName || \"div\", { ...props,\n      ref: e => this.htmlEl = e,\n      onInput: this.emitChange,\n      onBlur: this.props.onBlur || this.emitChange,\n      contentEditable: !this.props.disabled,\n      dangerouslySetInnerHTML: {\n        __html: html\n      }\n    }, this.props.children);\n  }\n\n  shouldComponentUpdate(nextProps) {\n    // We need not rerender if the change of props simply reflects the user's\n    // edits. Rerendering in this case would make the cursor/caret jump.\n    return (// Rerender if there is no element yet... (somehow?)\n      !this.htmlEl || // ...or if html really changed... (programmatically, not by user edit)\n      nextProps.html !== this.htmlEl.innerHTML && nextProps.html !== this.props.html || // ...or if editing is enabled or disabled.\n      this.props.disabled !== nextProps.disabled\n    );\n  }\n\n  componentDidUpdate() {\n    if (this.htmlEl && this.props.html !== this.htmlEl.innerHTML) {\n      // Perhaps React (whose VDOM gets outdated because we often prevent\n      // rerendering) did not update the DOM. So we update it manually now.\n      this.htmlEl.innerHTML = this.props.html;\n    }\n  }\n\n  emitChange(evt) {\n    if (!this.htmlEl) return;\n    var html = this.htmlEl.innerHTML;\n\n    if (this.props.onChange && html !== this.lastHtml) {\n      evt.target = {\n        value: html\n      };\n      this.props.onChange(evt);\n    }\n\n    this.lastHtml = html;\n  }\n\n}\n\nexport default ArticleEditor;","map":{"version":3,"sources":["C:/OpenMonzac/client/src/mainComponents/articleEditor.js"],"names":["React","Component","MonzacContext","ArticleEditor","constructor","emitChange","bind","render","tagName","html","onChange","props","createElement","ref","e","htmlEl","onInput","onBlur","contentEditable","disabled","dangerouslySetInnerHTML","__html","children","shouldComponentUpdate","nextProps","innerHTML","componentDidUpdate","evt","lastHtml","target","value"],"mappings":"AAAA,OAAOA,KAAP,IAAgBC,SAAhB,QAAiC,OAAjC;AACA,SAASC,aAAT,QAA8B,0BAA9B,C,CAEA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA,MAAMC,aAAN,SAA4BH,KAAK,CAACC,SAAlC,CAA4C;AAC1CG,EAAAA,WAAW,GAAG;AACZ;AACA,SAAKC,UAAL,GAAkB,KAAKA,UAAL,CAAgBC,IAAhB,CAAqB,IAArB,CAAlB;AACD;;AAEDC,EAAAA,MAAM,GAAG;AACP,QAAI;AAAEC,MAAAA,OAAF;AAAWC,MAAAA,IAAX;AAAiBC,MAAAA,QAAjB;AAA2B,SAAGC;AAA9B,QAAwC,KAAKA,KAAjD;AAEA;AACAX,IAAAA,KAAK,CAACY,aAAN,CACEJ,OAAO,IAAI,KADb,EAEE,EACE,GAAGG,KADL;AAEEE,MAAAA,GAAG,EAAGC,CAAD,IAAQ,KAAKC,MAAL,GAAcD,CAF7B;AAGEE,MAAAA,OAAO,EAAE,KAAKX,UAHhB;AAIEY,MAAAA,MAAM,EAAE,KAAKN,KAAL,CAAWM,MAAX,IAAqB,KAAKZ,UAJpC;AAKEa,MAAAA,eAAe,EAAE,CAAC,KAAKP,KAAL,CAAWQ,QAL/B;AAMEC,MAAAA,uBAAuB,EAAE;AAAEC,QAAAA,MAAM,EAAEZ;AAAV;AAN3B,KAFF,EAUE,KAAKE,KAAL,CAAWW,QAVb;AAYD;;AAEDC,EAAAA,qBAAqB,CAACC,SAAD,EAAY;AAC/B;AACA;AACA,WACE;AACA,OAAC,KAAKT,MAAN,IACA;AACCS,MAAAA,SAAS,CAACf,IAAV,KAAmB,KAAKM,MAAL,CAAYU,SAA/B,IACCD,SAAS,CAACf,IAAV,KAAmB,KAAKE,KAAL,CAAWF,IAHhC,IAIA;AACA,WAAKE,KAAL,CAAWQ,QAAX,KAAwBK,SAAS,CAACL;AAPpC;AASD;;AAEDO,EAAAA,kBAAkB,GAAG;AACnB,QAAI,KAAKX,MAAL,IAAe,KAAKJ,KAAL,CAAWF,IAAX,KAAoB,KAAKM,MAAL,CAAYU,SAAnD,EAA8D;AAC5D;AACA;AACA,WAAKV,MAAL,CAAYU,SAAZ,GAAwB,KAAKd,KAAL,CAAWF,IAAnC;AACD;AACF;;AAEDJ,EAAAA,UAAU,CAACsB,GAAD,EAAM;AACd,QAAI,CAAC,KAAKZ,MAAV,EAAkB;AAClB,QAAIN,IAAI,GAAG,KAAKM,MAAL,CAAYU,SAAvB;;AACA,QAAI,KAAKd,KAAL,CAAWD,QAAX,IAAuBD,IAAI,KAAK,KAAKmB,QAAzC,EAAmD;AACjDD,MAAAA,GAAG,CAACE,MAAJ,GAAa;AAAEC,QAAAA,KAAK,EAAErB;AAAT,OAAb;AACA,WAAKE,KAAL,CAAWD,QAAX,CAAoBiB,GAApB;AACD;;AACD,SAAKC,QAAL,GAAgBnB,IAAhB;AACD;;AAtDyC;;AAwD5C,eAAeN,aAAf","sourcesContent":["import React, { Component } from \"react\";\r\nimport { MonzacContext } from \"../context/monzacContext\";\r\n\r\n// class ArticleEditor extends Component {\r\n//   state = {};\r\n\r\n//   render() {\r\n//     return (\r\n//       <MonzacContext.Consumer>\r\n//         {(context) => (\r\n//           <p\r\n//             id=\"id-article-editor-content\"\r\n//             contentEditable\r\n//             onInput={context.updateNewArticleContent}\r\n//             data-placeholder=\"Write here...!\"\r\n//           ></p>\r\n//         )}\r\n//       </MonzacContext.Consumer>\r\n//     );\r\n//   }\r\n// }\r\n// export default ArticleEditor;\r\n\r\nclass ArticleEditor extends React.Component {\r\n  constructor() {\r\n    super();\r\n    this.emitChange = this.emitChange.bind(this);\r\n  }\r\n\r\n  render() {\r\n    var { tagName, html, onChange, ...props } = this.props;\r\n\r\n    return;\r\n    React.createElement(\r\n      tagName || \"div\",\r\n      {\r\n        ...props,\r\n        ref: (e) => (this.htmlEl = e),\r\n        onInput: this.emitChange,\r\n        onBlur: this.props.onBlur || this.emitChange,\r\n        contentEditable: !this.props.disabled,\r\n        dangerouslySetInnerHTML: { __html: html },\r\n      },\r\n      this.props.children\r\n    );\r\n  }\r\n\r\n  shouldComponentUpdate(nextProps) {\r\n    // We need not rerender if the change of props simply reflects the user's\r\n    // edits. Rerendering in this case would make the cursor/caret jump.\r\n    return (\r\n      // Rerender if there is no element yet... (somehow?)\r\n      !this.htmlEl ||\r\n      // ...or if html really changed... (programmatically, not by user edit)\r\n      (nextProps.html !== this.htmlEl.innerHTML &&\r\n        nextProps.html !== this.props.html) ||\r\n      // ...or if editing is enabled or disabled.\r\n      this.props.disabled !== nextProps.disabled\r\n    );\r\n  }\r\n\r\n  componentDidUpdate() {\r\n    if (this.htmlEl && this.props.html !== this.htmlEl.innerHTML) {\r\n      // Perhaps React (whose VDOM gets outdated because we often prevent\r\n      // rerendering) did not update the DOM. So we update it manually now.\r\n      this.htmlEl.innerHTML = this.props.html;\r\n    }\r\n  }\r\n\r\n  emitChange(evt) {\r\n    if (!this.htmlEl) return;\r\n    var html = this.htmlEl.innerHTML;\r\n    if (this.props.onChange && html !== this.lastHtml) {\r\n      evt.target = { value: html };\r\n      this.props.onChange(evt);\r\n    }\r\n    this.lastHtml = html;\r\n  }\r\n}\r\nexport default ArticleEditor;\r\n"]},"metadata":{},"sourceType":"module"}